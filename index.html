<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Runner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            margin: 0 auto;
            max-width: 600px;
            max-height: 100vh;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        class InfiniteRunner extends Phaser.Scene {
            constructor() {
                super({ key: 'InfiniteRunner' });
                this.gameState = 'menu';
                this.scrollSpeed = 800;
                this.jumpCount = 0;
                this.maxJumps = 3;
                this.gameTime = 0;
                this.spikeSpawnTimer = 0;
                this.spikeSpawnInterval = 2000;
                this.canJump = false;
                this.jumpCooldown = 0;
                this.jumpHoldTime = 0;

                this.gameAreaTop = 300;
                this.gameAreaBottom = 1300;
                this.gameAreaHeight = 1000;
                this.floorY = 1175;
                this.ceilingY = 300;

                this.runBouncePhase = 0;
                this.heroBaseY = 0;
            }

            preload() {
                this.load.image('hero', 'assets/hero.png');
                this.load.image('rock', 'assets/rock.png');
                this.load.image('hat', 'assets/hat.png');
                this.load.image('spike1', 'assets/spike1.png');
                this.load.image('spike2', 'assets/spike2.png');
                this.load.image('spike3', 'assets/spike3.png');
                this.load.image('floor', 'assets/floor.png');
                this.load.image('titlepic', 'assets/titlepic.png');

                this.load.on('loaderror', (file) => {
                    console.log('Failed to load:', file.src);
                });
            }

            create() {
                this.add.rectangle(500, 150, 1000, 300, 0x000000);
                this.add.rectangle(500, 800, 1000, 1000, 0x87CEEB);
                this.add.rectangle(500, 1450, 1000, 300, 0x000000);

                this.floorTiles = [];
                for (let i = 0; i < 3; i++) {
                    const tile = this.add.tileSprite(i * 1500, this.floorY, 3000, 250, 'floor');
                    tile.setOrigin(0, 0);
                    tile.setScale(0.5);
                    this.floorTiles.push(tile);
                }

                this.ceilingTiles = [];
                for (let i = 0; i < 3; i++) {
                    const tile = this.add.tileSprite(i * 1500, this.ceilingY, 3000, 250, 'floor');
                    tile.setOrigin(0, 1);
                    tile.setScale(0.5, -0.5);
                    this.ceilingTiles.push(tile);
                }

                this.platforms = this.physics.add.staticGroup();
                const ground = this.add.rectangle(500, this.floorY + 20, 2000, 40, 0xffffff);
                ground.setVisible(false);
                this.physics.add.existing(ground, true);
                this.platforms.add(ground);

                const ceiling = this.add.rectangle(500, this.ceilingY + 105, 2000, 40, 0xffffff);
                ceiling.setVisible(false);
                this.physics.add.existing(ceiling, true);
                this.platforms.add(ceiling);

                this.hero = this.physics.add.sprite(250, 1000, 'hero');
                this.hero.setDisplaySize(64, 64);
                this.hero.setBounce(0.1);
                this.hero.setCollideWorldBounds(true);

                this.boulder = this.physics.add.sprite(-200, this.floorY - 192, 'rock');
                this.boulder.setDisplaySize(384, 384);
                this.boulder.body.setSize(832, 832); // this is applied to boulder.png dimensions, not setDisplaySize
                this.boulder.setVisible(false);

                this.boulderHat = this.add.sprite(-200, this.floorY - 320, 'hat');
                this.boulderHat.setDisplaySize(256, 256);
                this.boulderHat.setVisible(false);

                this.spikes = this.physics.add.group();
                this.flyingSpikes = this.physics.add.group();

                this.timerText = this.add.text(500, 150, '00:00:00', {
                    fontSize: '128px',
                    fill: '#FFFFFF',
                    fontFamily: 'monospace'
                }).setOrigin(0.5);

                this.playButton = this.add.rectangle(500, 1450, 400, 120, 0x4CAF50);
                this.playButtonText = this.add.text(500, 1450, 'PLAY', {
                    fontSize: '64px',
                    fill: '#FFFFFF'
                }).setOrigin(0.5);

                this.playButton.setInteractive();
                this.playButton.on('pointerdown', () => this.startGame());

                this.restartButton = this.add.rectangle(500, 1450, 400, 120, 0xFF5722);
                this.restartButtonText = this.add.text(500, 1450, 'RESTART', {
                    fontSize: '64px',
                    fill: '#FFFFFF'
                }).setOrigin(0.5);

                this.restartButton.setVisible(false);
                this.restartButtonText.setVisible(false);
                this.restartButton.setInteractive();
                this.restartButton.on('pointerdown', () => this.restartGame());

                this.jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.on('pointerdown', () => {
                    if (this.canJump && this.gameState === 'playing' && this.jumpCooldown <= 0) {
                        this.jump();
                        this.jumpCooldown = 200;
                    }
                });

                this.physics.add.collider(this.hero, this.platforms);
                this.physics.add.collider(this.boulder, this.platforms);
                this.physics.add.overlap(this.hero, this.spikes, this.hitSpike, null, this);
                this.physics.add.overlap(this.boulder, this.spikes, this.boulderHitSpike, null, this);

                // Set world bounds to active game area
                this.physics.world.setBounds(0, this.gameAreaTop, 1000, this.gameAreaHeight);

                // Title screen
                this.titlePic = this.add.image(500, 800, 'titlepic');
                this.titlePic.setDisplaySize(1200, 760);
                this.titlePic.setDepth(1000);

                // Auto-slide title after 4 seconds
                this.titleTimer = this.time.delayedCall(4000, () => {
                    this.slideTitleAway();
                }, [], this);

                this.titleSliding = false;
            }

            startGame() {
                if (this.titlePic && this.titlePic.visible && !this.titleSliding) {
                    this.slideTitleAway();
                }

                this.gameState = 'playing';
                this.gameTime = 0;
                this.jumpCount = 0;
                this.canJump = false;
                this.time.delayedCall(100, () => { this.canJump = true; }, [], this);

                this.playButton.setVisible(false);
                this.playButtonText.setVisible(false);

                this.boulder.setVisible(true);
                this.boulder.x = 50;
                this.boulderHat.setVisible(true);

                this.hero.x = 250;
                this.hero.y = this.floorY - 32;
                this.hero.body.setVelocity(0, 0);
                this.hero.body.setGravityY(2400);
                this.hero.setRotation(0);

                this.spikes.clear(true, true);
                this.flyingSpikes.clear(true, true);

                console.log('Game started - Hero position:', this.hero.x, this.hero.y);
                console.log('Hero velocity:', this.hero.body.velocity.x, this.hero.body.velocity.y);
                console.log('Hero gravity:', this.hero.body.gravity.y);
            }

            slideTitleAway() {
                if (this.titleSliding) return;

                this.titleSliding = true;
                if (this.titleTimer) {
                    this.titleTimer.remove();
                }

                this.tweens.add({
                    targets: this.titlePic,
                    x: -1000,
                    duration: 800,
                    ease: 'Power2',
                    onComplete: () => {
                        this.titlePic.setVisible(false);
                        this.titleSliding = false;
                    }
                });
            }

            restartGame() {
                this.gameState = 'menu';

                this.restartButton.setVisible(false);
                this.restartButtonText.setVisible(false);
                this.playButton.setVisible(true);
                this.playButtonText.setVisible(true);

                this.boulder.setVisible(false);
                this.boulder.x = -200;
                this.boulder.y = this.floorY - 192;
                this.boulderHat.setVisible(false);
                this.boulderHat.x = -200;
                this.boulderHat.y = this.boulder.y - 128;

                this.hero.x = 250;
                this.hero.y = this.floorY - 32;
                this.hero.body.setVelocity(0, 0);
                this.hero.body.setGravityY(2400);
                this.hero.body.setAllowGravity(true);
                this.hero.body.setImmovable(false);
                this.hero.setRotation(0);
                this.hero.clearTint();
                this.tweens.killTweensOf(this.hero);

                this.spikes.clear(true, true);
                this.flyingSpikes.clear(true, true);

                this.gameTime = 0;
                this.jumpCount = 0;
                this.canJump = false;
                this.time.delayedCall(100, () => { this.canJump = true; }, [], this);

                console.log('Game restarted - Hero position:', this.hero.x, this.hero.y);
                console.log('Hero velocity:', this.hero.body.velocity.x, this.hero.body.velocity.y);
                console.log('Hero gravity:', this.hero.body.gravity.y);
            }

            jump() {
                if (this.jumpCount < this.maxJumps && this.jumpCooldown <= 0) {
                    const previousJumpCount = this.jumpCount;
                    this.jumpCount++;

                    if (this.jumpCount === 1 && previousJumpCount === 0) {
                        this.hero.body.setVelocityY(-1600);
                        this.hero.body.setGravityY(2400);
                        this.hero.setRotation(0);
                        console.log('First jump initiated - Velocity:', this.hero.body.velocity.y);
                    } else if (this.jumpCount === 2 && previousJumpCount === 1) {
                        this.hero.body.setVelocityY(-1200);
                        this.hero.body.setGravityY(1500);
                        this.tweens.killTweensOf(this.hero);
                        this.hero.setRotation(0);
                        this.tweens.add({
                            targets: this.hero,
                            rotation: Math.PI * 2,
                            duration: 300,
                            ease: 'Power2'
                        });
                    } else if (this.jumpCount === 3 && previousJumpCount === 2) {
                        this.hero.body.setVelocityY(-500);
                        this.hero.body.setGravityY(800);
                        this.hero.setRotation(0);
                        this.tweens.add({
                            targets: this.hero,
                            x: this.hero.x - 20,
                            duration: 80,
                            yoyo: true,
                            repeat: 5,
                            ease: 'Sine.inOut'
                        });
                        this.tweens.add({
                            targets: this.hero,
                            y: this.hero.y - 5,
                            duration: 60,
                            yoyo: true,
                            repeat: 7,
                            ease: 'Sine.inOut'
                        });
                    }
                    this.jumpCooldown = 200; // 200ms cooldown between jumps
                }
            }

            update(time, delta) {
                if (this.gameState === 'playing') {
                    this.gameTime += delta;
                    const totalCentiseconds = Math.floor(this.gameTime / 10);
                    const minutes = Math.floor(totalCentiseconds / 6000);
                    const seconds = Math.floor((totalCentiseconds % 6000) / 100);
                    const centiseconds = totalCentiseconds % 100;
                    this.timerText.setText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${centiseconds.toString().padStart(2, '0')}`);

                    if (this.jumpCooldown > 0) {
                        this.jumpCooldown -= delta;
                    }

                    if (Phaser.Input.Keyboard.JustDown(this.jumpKey) && this.canJump && this.jumpCooldown <= 0) {
                        this.jump();
                        this.jumpCooldown = 200;
                    }

                    if (this.hero.body.touching.down) {
                        this.jumpCount = 0;
                        this.hero.body.setGravityY(2400);
                        if (!this.tweens.isTweening(this.hero)) {
                            this.hero.setRotation(0);
                        }
                        console.log('Hero grounded - Jump count reset');
                    }

                    if (this.hero.body.touching.down && this.jumpCount === 0) {
                        if (!this.heroBaseY) {
                            this.heroBaseY = this.hero.y;
                        }
                        this.runBouncePhase += 0.5;
                        const bounce = Math.abs(Math.sin(this.runBouncePhase)) * 10;
                        this.hero.y = this.heroBaseY - bounce;
                        const rotation = Math.sin(this.runBouncePhase) * 0.174533;
                        this.hero.setRotation(rotation);
                    } else {
                        this.heroBaseY = 0;
                    }

                    const scrollDelta = this.scrollSpeed * delta / 1000;

                    this.floorTiles.forEach((tile) => {
                        tile.tilePositionX += scrollDelta * 2;
                    });

                    this.ceilingTiles.forEach((tile) => {
                        tile.tilePositionX += scrollDelta * 2;
                    });

                    this.boulder.rotation += 0.08;
                    this.boulderHat.x = this.boulder.x;
                    this.boulderHat.y = this.boulder.y - 192 + Math.sin(time * 0.01) * 10;

                    this.spikeSpawnTimer += delta;
                    if (this.spikeSpawnTimer >= this.spikeSpawnInterval) {
                        this.spawnSpike();
                        this.spikeSpawnTimer = 0;
                    }

                    this.spikes.children.entries.forEach(spike => {
                        spike.x -= scrollDelta;
                        if (spike.x < -100) {
                            spike.destroy();
                        }
                    });

                    this.flyingSpikes.children.entries.forEach(spike => {
                        spike.rotation += 0.3;
                        if (spike.x > 1100 || spike.x < -100 || spike.y > 1400 || spike.y < 200) {
                            spike.destroy();
                        }
                    });

                    if (this.hero.x <= this.boulder.x + 150) {
                        this.gameOver();
                    }
                }

                if (this.gameState === 'dead') {
                    const scrollDelta = this.scrollSpeed * delta / 1000;
                    this.boulder.x += scrollDelta * 2;
                    this.boulder.rotation += 0.1;
                    this.boulderHat.x = this.boulder.x;
                    this.boulderHat.y = this.boulder.y - 192 + Math.sin(time * 0.01) * 10;

                    if (this.boulder.x > 1100) {
                        this.restartButton.setVisible(true);
                        this.restartButtonText.setVisible(true);
                    }
                }
            }

            spawnSpike() {
                const spikeTypes = ['spike3', 'spike2', 'spike1']; // short, medium, tall
                const positions = ['ground', 'ceiling'];

                const spikeType = Phaser.Utils.Array.GetRandom(spikeTypes);
                const position = Phaser.Utils.Array.GetRandom(positions);

                let spike;
                if (position === 'ground') {
                    spike = this.spikes.create(1100, this.floorY, spikeType);
                    spike.setOrigin(0.5, 1);
                    spike.setScale(0.5);
                } else {
                    spike = this.spikes.create(1100, this.ceilingY + 125, spikeType);
                    spike.setOrigin(0.5, 0);
                    spike.setScale(0.5);
                    spike.setFlipY(true);
                }

                spike.body.setAllowGravity(false);
                spike.body.setImmovable(true);

                console.log('Spawning', position, spikeType, '- Y:', spike.y);
            }

            hitSpike(hero, spike) {
                this.gameOver();
            }

            boulderHitSpike(boulder, spike) {
                const flyingSpike = this.flyingSpikes.create(spike.x, spike.y, spike.texture.key);
                flyingSpike.setScale(0.5);
                flyingSpike.setFlipY(spike.flipY);
                flyingSpike.body.setVelocity(
                    Phaser.Math.Between(300, 600),
                    Phaser.Math.Between(-600, -300)
                );
                flyingSpike.body.setAngularVelocity(Phaser.Math.Between(300, 600));
                flyingSpike.body.setGravityY(800);
                spike.destroy();
            }

            gameOver() {
                this.gameState = 'dead';
                this.hero.setTint(0xff0000);
                this.hero.body.setVelocity(0, 0);
                this.hero.body.setAllowGravity(false);
                this.hero.body.setImmovable(true);
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 1200 },
                    debug: true
                }
            },
            scene: InfiniteRunner,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>