<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Infinite Runner</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/phaser/3.70.0/phaser.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: #2c3e50;
            font-family: Arial, sans-serif;
            touch-action: none;
            overflow: hidden;
        }

        #game-container {
            width: 100%;
            height: 100vh;
            position: relative;
            margin: 0 auto;
            max-width: 600px;
            max-height: 100vh;
        }
    </style>
</head>

<body>
    <div id="game-container"></div>

    <script>
        class InfiniteRunner extends Phaser.Scene {
            constructor() {
                super({ key: 'InfiniteRunner' });
                this.gameState = 'menu';
                this.scrollSpeed = 300;
                this.jumpVelocity = -600;
                this.doubleJumpVelocity = -400;
                this.tripleJumpVelocity = -300;
                this.currentJump = 0;
                this.canJump = true;
                this.gameTime = 0;
                this.spikeSpawnTimer = 0;
                this.spikeSpawnInterval = 2000;

                // Game area - 1000x1000 centered in 1000x1600
                this.gameAreaTop = 300;
                this.gameAreaBottom = 1300;
                this.gameAreaHeight = 1000;
                this.floorY = 1175;
                this.ceilingY = 300;

                this.runBouncePhase = 0;
                this.heroBaseY = 0;

                // Spike original dimensions
                this.spikeOriginalWidth = 118;
                this.spikeOriginalHeight = 946;
            }

            preload() {
                // Load assets
                this.load.image('hero', 'assets/hero.png');
                this.load.image('rock', 'assets/rock.png');
                this.load.image('hat', 'assets/hat.png');
                this.load.image('spike', 'assets/spike.png');
                this.load.image('floor', 'assets/floor.png');

                this.load.on('loaderror', (file) => {
                    console.log('Failed to load:', file.src);
                });
            }

            create() {
                // Background
                this.add.rectangle(500, 150, 1000, 300, 0x000000);
                this.add.rectangle(500, 800, 1000, 1000, 0x87CEEB);
                this.add.rectangle(500, 1450, 1000, 300, 0x000000);

                // Floor visual
                this.floorTiles = [];
                for (let i = 0; i < 3; i++) {
                    const tile = this.add.tileSprite(i * 750, this.floorY, 1500, 250, 'floor');
                    tile.setOrigin(0, 0);
                    tile.setScale(0.5);
                    this.floorTiles.push(tile);
                }

                // Create ground collision using a rectangle - position it slightly below floor line
                this.platforms = this.physics.add.staticGroup();

                // Create ground as a rectangle - position at floor line + 20 pixels down
                const ground = this.add.rectangle(500, this.floorY + 20, 2000, 40, 0xffffff);
                ground.setVisible(false);
                this.physics.add.existing(ground, true);
                this.platforms.add(ground);

                // Create ceiling as a rectangle
                const ceiling = this.add.rectangle(500, this.ceilingY, 2000, 40, 0xffffff);
                ceiling.setVisible(false);
                this.physics.add.existing(ceiling, true);
                this.platforms.add(ceiling);

                // Hero
                this.hero = this.physics.add.sprite(250, 1000, 'hero');
                this.hero.setDisplaySize(64, 64);
                this.hero.setBounce(0.1);
                this.hero.setCollideWorldBounds(true);

                // Boulder
                this.boulder = this.physics.add.sprite(-200, this.floorY - 128, 'rock');
                this.boulder.setDisplaySize(256, 256);
                this.boulder.setVisible(false);

                // Hat
                this.boulderHat = this.add.sprite(-200, this.floorY - 256, 'hat');
                this.boulderHat.setDisplaySize(128, 128);
                this.boulderHat.setVisible(false);

                // Spike groups
                this.spikes = this.physics.add.group();
                this.flyingSpikes = this.physics.add.group();

                // Timer - in the black area, white text
                this.timerText = this.add.text(850, 50, '00:00:00', {
                    fontSize: '24px',
                    fill: '#FFFFFF',
                    fontFamily: 'monospace'
                });

                // Menu
                this.playButton = this.add.rectangle(500, 800, 200, 80, 0x4CAF50);
                this.playButtonText = this.add.text(500, 800, 'PLAY', {
                    fontSize: '32px',
                    fill: '#FFFFFF'
                }).setOrigin(0.5);

                this.playButton.setInteractive();
                this.playButton.on('pointerdown', () => this.startGame());

                // Restart button
                this.restartButton = this.add.rectangle(500, 850, 200, 80, 0xFF5722);
                this.restartButtonText = this.add.text(500, 850, 'RESTART', {
                    fontSize: '28px',
                    fill: '#FFFFFF'
                }).setOrigin(0.5);

                this.restartButton.setVisible(false);
                this.restartButtonText.setVisible(false);
                this.restartButton.setInteractive();
                this.restartButton.on('pointerdown', () => this.restartGame());

                // Input
                this.jumpKey = this.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes.SPACE);
                this.input.on('pointerdown', () => {
                    if (this.gameState === 'playing') {
                        this.jump();
                    }
                });

                // Physics
                this.physics.add.collider(this.hero, this.platforms);
                this.physics.add.collider(this.boulder, this.platforms);
                this.physics.add.overlap(this.hero, this.spikes, this.hitSpike, null, this);
                this.physics.add.overlap(this.boulder, this.spikes, this.boulderHitSpike, null, this);
            }

            startGame() {
                this.gameState = 'playing';
                this.gameTime = 0;
                this.currentJump = 0;
                this.canJump = true;

                this.playButton.setVisible(false);
                this.playButtonText.setVisible(false);

                // Show boulder
                this.boulder.setVisible(true);
                this.boulder.x = 50;
                this.boulderHat.setVisible(true);

                // Reset hero
                this.hero.x = 250;
                this.hero.y = 1000;
                this.hero.body.setVelocity(0, 0);
                this.hero.setRotation(0);

                // Clear spikes
                this.spikes.clear(true, true);
                this.flyingSpikes.clear(true, true);
            }

            restartGame() {
                this.gameState = 'menu';

                this.restartButton.setVisible(false);
                this.restartButtonText.setVisible(false);
                this.playButton.setVisible(true);
                this.playButtonText.setVisible(true);

                this.boulder.setVisible(false);
                this.boulder.x = -200;
                this.boulderHat.setVisible(false);

                this.hero.x = 250;
                this.hero.y = 1000;
                this.hero.body.setVelocity(0, 0);
                this.hero.setRotation(0);
                this.hero.clearTint();

                this.spikes.clear(true, true);
                this.flyingSpikes.clear(true, true);

                this.gameTime = 0;
                this.currentJump = 0;
            }

            jump() {
                const onGround = this.hero.body.touching.down;

                if (this.currentJump === 0 && onGround) {
                    // First jump
                    this.hero.body.setVelocityY(this.jumpVelocity);
                    this.currentJump = 1;
                } else if (this.currentJump === 1 && this.canJump) {
                    // Double jump
                    this.hero.body.setVelocityY(this.doubleJumpVelocity);
                    this.currentJump = 2;
                    this.canJump = false;

                    // Rotation animation
                    this.tweens.add({
                        targets: this.hero,
                        rotation: Math.PI * 2,
                        duration: 500,
                        ease: 'Linear'
                    });
                } else if (this.currentJump === 2 && this.canJump) {
                    // Triple jump
                    this.hero.body.setVelocityY(this.tripleJumpVelocity);
                    this.currentJump = 3;
                    this.canJump = false;

                    // Temporarily reduce gravity for float effect
                    this.hero.body.setGravityY(400);

                    // Shake animation
                    this.tweens.add({
                        targets: this.hero,
                        x: this.hero.x + 5,
                        duration: 50,
                        yoyo: true,
                        repeat: 10,
                        ease: 'Linear',
                        onComplete: () => {
                            this.hero.body.setGravityY(0); // Reset to world gravity
                        }
                    });
                }
            }

            update(time, delta) {
                if (this.gameState === 'playing') {
                    // Update timer
                    this.gameTime += delta;
                    const totalCentiseconds = Math.floor(this.gameTime / 10);
                    const minutes = Math.floor(totalCentiseconds / 6000);
                    const seconds = Math.floor((totalCentiseconds % 6000) / 100);
                    const centiseconds = totalCentiseconds % 100;
                    this.timerText.setText(`${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}:${centiseconds.toString().padStart(2, '0')}`);

                    // Handle keyboard jump
                    if (Phaser.Input.Keyboard.JustDown(this.jumpKey)) {
                        this.jump();
                    }

                    // Reset jump when landing
                    if (this.hero.body.touching.down && this.currentJump > 0) {
                        this.currentJump = 0;
                        this.hero.setRotation(0);
                    }

                    // Allow next jump after key release
                    if (Phaser.Input.Keyboard.JustUp(this.jumpKey)) {
                        this.canJump = true;
                    }

                    // Running bounce effect - visual only
                    if (this.hero.body.touching.down && this.currentJump === 0) {
                        if (!this.heroBaseY) {
                            this.heroBaseY = this.hero.y;
                        }
                        this.runBouncePhase += 0.15;
                        const bounce = Math.sin(this.runBouncePhase) * 2;
                        this.hero.y = this.heroBaseY + bounce;
                    } else {
                        this.heroBaseY = 0;
                    }

                    // Scroll floor
                    this.floorTiles.forEach((tile, i) => {
                        tile.tilePositionX += this.scrollSpeed * delta / 1000;
                    });

                    // Boulder animation
                    this.boulder.rotation += 0.05;
                    this.boulderHat.x = this.boulder.x;
                    this.boulderHat.y = this.boulder.y - 128 + Math.sin(time * 0.01) * 10;

                    // Spawn spikes
                    this.spikeSpawnTimer += delta;
                    if (this.spikeSpawnTimer >= this.spikeSpawnInterval) {
                        this.spawnSpike();
                        this.spikeSpawnTimer = 0;
                    }

                    // Move spikes
                    this.spikes.children.entries.forEach(spike => {
                        spike.x -= this.scrollSpeed * delta / 1000;
                        if (spike.x < -100) {
                            spike.destroy();
                        }
                    });

                    // Update flying spikes
                    this.flyingSpikes.children.entries.forEach(spike => {
                        spike.rotation += 0.3;
                        if (spike.x > 1100 || spike.x < -100 || spike.y > 1400 || spike.y < 200) {
                            spike.destroy();
                        }
                    });

                    // Check boulder collision
                    if (this.hero.x <= this.boulder.x + 100) {
                        this.gameOver();
                    }
                }

                if (this.gameState === 'dead') {
                    // Boulder rampage
                    this.boulder.x += this.scrollSpeed * 2 * delta / 1000;
                    this.boulder.rotation += 0.1;
                    this.boulderHat.x = this.boulder.x;
                    this.boulderHat.y = this.boulder.y - 128 + Math.sin(time * 0.01) * 10;

                    if (this.boulder.x > 1100) {
                        this.restartButton.setVisible(true);
                        this.restartButtonText.setVisible(true);
                    }
                }
            }

            spawnSpike() {
                const heights = [0.2, 0.4, 0.6];
                const positions = ['ground', 'ceiling'];

                const height = Phaser.Utils.Array.GetRandom(heights);
                const position = Phaser.Utils.Array.GetRandom(positions);

                let spike;
                const gameAreaUsableHeight = this.gameAreaHeight - 200;

                if (position === 'ground') {
                    const spikeHeight = gameAreaUsableHeight * height;
                    spike = this.spikes.create(1100, this.floorY, 'spike');

                    // Crop the sprite from top
                    const cropHeight = (spikeHeight / this.spikeOriginalHeight) * this.spikeOriginalHeight;
                    spike.setCrop(0, this.spikeOriginalHeight - cropHeight, this.spikeOriginalWidth, cropHeight);
                    spike.setOrigin(0.5, 1);

                    // Set physics body
                    spike.body.setSize(40, spikeHeight * 0.9);
                    spike.body.setOffset(39, cropHeight * 0.1);
                } else {
                    const spikeHeight = gameAreaUsableHeight * height;
                    spike = this.spikes.create(1100, this.ceilingY, 'spike');

                    // Crop the sprite from bottom
                    spike.setCrop(0, 0, this.spikeOriginalWidth, spikeHeight);
                    spike.setOrigin(0.5, 0);
                    spike.setFlipY(true);

                    // Set physics body
                    spike.body.setSize(40, spikeHeight * 0.9);
                    spike.body.setOffset(39, 0);
                }

                spike.body.setAllowGravity(false);
                spike.body.setImmovable(true);
            }

            hitSpike(hero, spike) {
                this.gameOver();
            }

            boulderHitSpike(boulder, spike) {
                const flyingSpike = this.flyingSpikes.create(spike.x, spike.y, 'spike');

                // Copy the crop
                if (spike.frame.cutWidth && spike.frame.cutHeight) {
                    flyingSpike.setCrop(spike.frame.cutX, spike.frame.cutY, spike.frame.cutWidth, spike.frame.cutHeight);
                }
                flyingSpike.setFlipY(spike.flipY);

                flyingSpike.body.setVelocity(
                    Phaser.Math.Between(300, 600),
                    Phaser.Math.Between(-600, -300)
                );
                flyingSpike.body.setAngularVelocity(Phaser.Math.Between(300, 600));
                flyingSpike.body.setGravityY(800);

                spike.destroy();
            }

            gameOver() {
                this.gameState = 'dead';
                this.hero.setTint(0xff0000);
                this.hero.body.setVelocity(0, 0);
                this.hero.body.setAllowGravity(false);
                this.hero.body.setImmovable(true);
            }
        }

        const config = {
            type: Phaser.AUTO,
            width: 1000,
            height: 1600,
            parent: 'game-container',
            physics: {
                default: 'arcade',
                arcade: {
                    gravity: { y: 1200 },
                    debug: false
                }
            },
            scene: InfiniteRunner,
            scale: {
                mode: Phaser.Scale.FIT,
                autoCenter: Phaser.Scale.CENTER_BOTH
            }
        };

        const game = new Phaser.Game(config);
    </script>
</body>

</html>